{% extends 'base.html' %}

{% block content %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Header / Search -->
<section class="flex flex-col md:flex-row gap-4 justify-between items-end border-b border-gray-800 pb-8">
    <div class="w-full md:w-1/2">
        <h2 class="text-3xl font-bold text-white mb-2">My Diary Analytics</h2>
        <div class="flex items-center gap-4">
            <div class="flex items-center gap-2 bg-gray-800 rounded px-2 py-1" id="year-nav"
                style="visibility: hidden;">
                <button onclick="changeYear(1)" class="text-accent hover:text-white font-mono text-xl">&lt;</button>
                <span id="current-year-display" class="font-mono text-white font-bold">ALL TIME</span>
                <button onclick="changeYear(-1)" class="text-accent hover:text-white font-mono text-xl">&gt;</button>
            </div>
            <p class="text-sm font-mono opacity-60">Displaying data for selected year.</p>
        </div>
    </div>
    <div class="w-full md:w-auto flex gap-2">
        <input type="text" id="username-input" placeholder="Letterboxd Username"
            class="bg-card border border-gray-700 text-white px-4 py-2 font-mono text-sm rounded-none focus:outline-none focus:border-accent w-full md:w-64">
        <button onclick="fetchData()" id="scrape-btn"
            class="bg-accent hover:bg-accentDark text-black font-mono font-bold uppercase px-6 py-2 transition-colors">
            SYNC_DATA
        </button>
    </div>
</section>

<!-- Stats Grid -->
<div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

    <!-- Module A: Cinema Graph (Heatmap) -->
    <div class="lg:col-span-2 bg-card rounded-lg p-6 border border-gray-800 relative">
        <div class="flex justify-between items-start mb-6">
            <div>
                <h3 class="font-mono text-white text-lg">CINEMA GRAPH <span class="text-xs opacity-50 ml-2"
                        id="heatmap-subtitle">THIS YEAR</span></h3>
            </div>
            <div class="flex flex-col items-end gap-2">
                <!-- History Button Removed -->
                <div class="text-[10px] font-mono flex gap-1 items-center opacity-60">
                    <span>LESS</span>
                    <div class="w-2 h-2 bg-heat0"></div>
                    <div class="w-2 h-2 bg-heat1"></div>
                    <div class="w-2 h-2 bg-heat2"></div>
                    <div class="w-2 h-2 bg-heat3"></div>
                    <span>MORE</span>
                </div>
            </div>
        </div>

        <!-- Heatmap Grid -->
        <div class="w-full overflow-hidden flex flex-col gap-1">
            <!-- Algorithm: 
                 12 Columns (Months) ? No, standard Git style is columns=weeks.
                 But user asked for Month Labels.
                 We will render a flex container with 12 blocks for months? Or just a huge grid with overlays.
                 Let's stick to the grid but add labels above.
            -->
            <div class="flex justify-between text-[10px] font-mono text-gray-500 px-1 mb-1" id="heatmap-months">
                <!-- JS Populated: Jan Feb Mar ... -->
            </div>
            <div id="heatmap-grid" class="grid grid-rows-7 grid-flow-col gap-[2px] w-full">
                <!-- JS populated -->
            </div>
        </div>

        <div class="mt-4 flex justify-between font-mono text-xs text-textMain">
            <div>TOTAL: <span id="stat-total" class="text-white">0</span> FILMS</div>
            <div>AVG RATING: <span id="stat-avg" class="text-white">0.0</span></div>
        </div>
    </div>

    <!-- Module B: Genre Network Graph (D3) -->
    <div class="bg-card rounded-lg p-6 border border-gray-800 flex flex-col h-full relative overflow-hidden">
        <h3 class="font-mono text-white text-lg mb-2 relative z-10">GENRE NETWORK</h3>
        <p class="text-xs font-mono opacity-50 mb-4 relative z-10">Size = Popularity</p>

        <div id="genre-network" class="absolute inset-0 top-12 cursor-move"></div>

        <!-- Legend/Tooltip container -->
        <div class="absolute bottom-4 left-4 z-10 pointer-events-none">
            <div id="genre-tooltip" class="text-white font-mono text-xs bg-black/80 px-2 py-1 rounded hidden"></div>
        </div>
    </div>
</div>

<!-- Row 2 -->
<div class="grid grid-cols-1 md:grid-cols-2 gap-6">

    <!-- Module C: Genre Evolution Graph -->
    <div class="bg-card rounded-lg p-6 border border-gray-800">
        <h3 class="font-mono text-white text-lg mb-4">GENRE EVOLUTION</h3>
        <div class="w-full h-64">
            <canvas id="evolution-chart"></canvas>
        </div>
    </div>

    <!-- Module D: Recommendations -->
    <div class="bg-card rounded-lg p-6 border border-gray-800 flex flex-col">
        <h3 class="font-mono text-white text-lg mb-4">RECOMMENDATIONS <span class="text-xs opacity-50 ml-2">BASED ON
                TASTE</span></h3>

        <div id="recs-container" class="flex-grow flex gap-4 overflow-x-auto items-center p-2 snap-x scrollbar-hide">
            <div class="text-center w-full font-mono text-sm opacity-50">Sync data to unlock recommendations.</div>
        </div>
    </div>

</div>

<!-- Full History Modal -->
<div id="history-modal"
    class="fixed inset-0 z-50 hidden bg-black/90 backdrop-blur-sm flex items-center justify-center p-4">
    <div class="bg-card w-full max-w-6xl max-h-[90vh] rounded-lg border border-gray-700 flex flex-col shadow-2xl">
        <div class="p-6 border-b border-gray-800 flex justify-between items-center">
            <h2 class="text-xl font-mono text-white">FULL DIARY HISTORY</h2>
            <button onclick="closeHistoryModal()" class="text-white font-mono hover:text-accent">[CLOSE]</button>
        </div>
        <div class="p-6 overflow-y-auto overflow-x-auto flex-grow">
            <div class="min-w-max">
                <div id="full-history-grid" class="grid grid-rows-7 grid-flow-col gap-1 w-max"></div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script>
    // State
    let availableYears = [];
    let currentYearIndex = 0; // 0 = latest
    let allEvolutionData = {};
    let evolutionChartInstance = null;

    // --- Year Navigation ---
    async function updateDashboard(year) {
        document.getElementById('current-year-display').textContent = year;

        // Fetch stats for year
        try {
            const res = await fetch(`/api/stats?year=${year}`);
            const stats = await res.json();

            // Render Stats
            document.getElementById('stat-total').textContent = stats.total_films;
            document.getElementById('stat-avg').textContent = stats.average_rating;
            document.getElementById('heatmap-subtitle').textContent = year;

            // Render Heatmap (Pass year context to generate correct grid for that year)
            renderHeatmap(stats.heatmap_data, year);

            // Render D3 Genre Graph
            renderGenreNetwork(stats.top_genres);

            // Reload Recs (uses full profile mostly, but refreshes checks)
            loadRecommendations();

            // Reload Evolution (Year Specific)
            loadEvolution(year);

        } catch (e) {
            console.error("Failed to update dashboard", e);
        }
    }

    function changeYear(delta) {
        // Delta +1 means GO BACK in time (older), -1 means NEWER
        // availableYears is sorted Descending [2025, 2024, ...]
        // So +1 index = Older year.
        const newIndex = currentYearIndex + delta;
        if (newIndex >= 0 && newIndex < availableYears.length) {
            currentYearIndex = newIndex;
            updateDashboard(availableYears[currentYearIndex]);
        }
    }

    // --- Heatmap ---
    function renderHeatmap(data, yearStr) {
        const grid = document.getElementById('heatmap-grid');
        grid.innerHTML = '';
        const monthsDiv = document.getElementById('heatmap-months');
        monthsDiv.innerHTML = '';

        const year = parseInt(yearStr);
        const start = new Date(year, 0, 1); // Jan 1st
        const end = new Date(year, 11, 31); // Dec 31st

        // Populate Grid
        // We need exactly 52 or 53 weeks.
        // Or just map every day of the year.
        // Let's iterate day by day.

        let current = new Date(start);

        // Labels logic: Simplified. Just add 12 items.
        const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
        months.forEach(m => {
            const s = document.createElement('span');
            s.textContent = m;
            monthsDiv.appendChild(s);
        });

        while (current <= end) {
            const dateStr = current.toISOString().split('T')[0];
            const count = data[dateStr] || 0;

            const div = document.createElement('div');
            div.className = `w-full aspect-square rounded-[1px] md:rounded-sm transition-colors duration-200`;

            if (count === 0) div.classList.add('bg-heat0');
            else if (count === 1) div.classList.add('bg-heat1');
            else if (count === 2) div.classList.add('bg-heat2');
            else div.classList.add('bg-heat3');

            div.title = `${dateStr}: ${count}`;
            grid.appendChild(div);

            current.setDate(current.getDate() + 1);
        }
    }

    // --- D3 Network Graph ---
    function renderGenreNetwork(genres) {
        // genres is [[name, count], ...]
        const container = document.getElementById('genre-network');
        container.innerHTML = '';
        const width = container.clientWidth;
        const height = container.clientHeight;

        if (!genres.length) return;

        // 1. LIMIT TO TOP 10
        const topGenres = genres.slice(0, 10);

        // Prepare nodes
        const nodes = topGenres.map(g => ({ id: g[0], val: g[1] }));

        // Scale radius better
        // Find max value to normalize
        const maxVal = Math.max(...nodes.map(n => n.val));
        const radiusScale = d3.scaleSqrt().domain([0, maxVal]).range([15, 60]); // Scale up to 60px

        // Simple force simulation
        const simulation = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(5))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => radiusScale(d.val) + 2).strength(0.7)); // Add padding

        const svg = d3.select('#genre-network').append('svg')
            .attr('width', width)
            .attr('height', height);

        const node = svg.append('g')
            .selectAll('g')
            .data(nodes)
            .join('g')
            .attr('cursor', 'pointer')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Circles (OPAQUE as requested)
        node.append('circle')
            .attr('r', d => radiusScale(d.val))
            .attr('fill', (d, i) => d3.schemeTableau10[i % 10])
            .attr('opacity', 1.0)
            .attr('stroke', '#1a1a1a')
            .attr('stroke-width', 2);

        // Labels (Only show if radius > 20)
        node.append('text')
            .text(d => d.id)
            .attr('text-anchor', 'middle')
            .attr('dy', '.35em')
            .attr('fill', 'white')
            .style('font-size', d => Math.min(14, radiusScale(d.val) / 2) + 'px') // Dynamic font size
            .style('font-family', 'monospace')
            .style('font-weight', 'bold')
            .style('pointer-events', 'none')
            .style('text-shadow', '1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000') // Outline
            .style('display', d => radiusScale(d.val) > 20 ? 'block' : 'none');

        simulation.on('tick', () => {
            node.attr('transform', d => {
                // Keep within bounds
                d.x = Math.max(radiusScale(d.val), Math.min(width - radiusScale(d.val), d.x));
                d.y = Math.max(radiusScale(d.val), Math.min(height - radiusScale(d.val), d.y));
                return `translate(${d.x},${d.y})`;
            });
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }

    // --- Evolution Chart (Chart.js) ---
    async function loadEvolution() {
        try {
            const res = await fetch('/api/evolution');
            const data = await res.json();

            // Transform for Chart.js
            // Data: { year: {genre: count} }
            const years = Object.keys(data).sort();

            // Find top genres overall to limit lines
            const totalCounts = {};
            Object.values(data).forEach(yData => {
                Object.entries(yData).forEach(([g, c]) => {
                    totalCounts[g] = (totalCounts[g] || 0) + c;
                });
            });
            const topGenres = Object.entries(totalCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5) // Top 5 only
                .map(x => x[0]);

            const datasets = topGenres.map((genre, i) => {
                const colors = ['#ec4899', '#22d3ee', '#fb923c', '#a3e635', '#c084fc'];
                return {
                    label: genre,
                    data: years.map(y => data[y][genre] || 0),
                    borderColor: colors[i % colors.length],
                    backgroundColor: colors[i % colors.length] + '20',
                    tension: 0.4,
                    fill: true
                };
            });

            const ctx = document.getElementById('evolution-chart').getContext('2d');

            if (evolutionChartInstance) evolutionChartInstance.destroy();

            evolutionChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: 'white', font: { family: 'monospace' } } }
                    },
                    scales: {
                        y: {
                            grid: { color: '#333' },
                            ticks: { color: '#888' }
                        },
                        x: {
                            grid: { color: '#333' },
                            ticks: { color: '#888' }
                        }
                    }
                }
            });

        } catch (e) {
            console.error("Evolution load failed", e);
        }
    }

    // --- Scrape Logic (Modified for Batching) ---
    async function fetchData() {
        const btn = document.getElementById('scrape-btn');
        const input = document.getElementById('username-input');
        const username = input.value.trim();

        if (!username) return alert("Please enter a username");

        btn.textContent = "SYNCING...";
        btn.disabled = true;

        let page = 1;
        let keepFetching = true;
        let totalMovies = 0;

        try {
            // LOOP
            while (keepFetching) {
                btn.textContent = `SYNCING PG ${page}...`;

                const response = await fetch('/api/sync/batch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, page })
                });

                if (!response.ok) {
                    keepFetching = false;
                    const text = await response.text();
                    console.error("HTTP Error:", response.status, text);
                    alert(`Error ${response.status}: ${text.substring(0, 100)}...`);
                    break;
                }

                const result = await response.json();

                if (result.status === "error") {
                    keepFetching = false;
                    console.error("API Error:", result);
                    alert("API Error: " + result.message);
                    break;
                }

                if (result.entries && result.entries.length > 0) {
                    totalMovies += result.entries.length;

                    // Update State & UI
                    availableYears = result.years;
                    currentYearIndex = 0; // Latest

                    document.getElementById('year-nav').style.visibility = 'visible';
                    updateDashboard(result.latest_year);
                    loadEvolution();
                }

                if (!result.has_next) {
                    keepFetching = false;
                } else {
                    page++;
                }

                // Small delay
                await new Promise(r => setTimeout(r, 100));
            }

            btn.textContent = "SYNC_DATA";
            btn.disabled = false;

        } catch (e) {
            console.error("Fetch Logic Error:", e);
            alert("Network Error: " + e.message);
            btn.textContent = "SYNC_DATA";
            btn.disabled = false;
        }
    }

    // --- Recommendations ---
    async function loadRecommendations() {
        const container = document.getElementById('recs-container');
        container.innerHTML = '<div class="text-xs text-center w-full opacity-50">Loading Recs...</div>';
        try {
            const res = await fetch('/api/recommendations');
            const recs = await res.json();

            if (recs.length === 0) {
                container.innerHTML = '<div class="text-xs text-center w-full opacity-50">No recs available.</div>';
                return;
            }
            container.innerHTML = '';
            recs.forEach(movie => {
                const card = document.createElement('div');
                card.className = "flex-none w-32 md:w-40 snap-start flex flex-col gap-2";
                card.innerHTML = `
                    <div class="relative aspect-[2/3] overflow-hidden rounded-md group cursor-pointer shadow-lg bg-gray-800">
                        <img src="${movie.poster_url}" alt="${movie.title}" class="object-cover w-full h-full transform transition-transform group-hover:scale-110">
                        <div class="absolute top-2 right-2 bg-black/80 text-accent text-xs font-mono px-1.5 py-0.5 rounded backdrop-blur">Match</div>
                    </div>
                    <div class="text-xs font-mono text-white truncate">${movie.title}</div>
                `;
                container.appendChild(card);
            });
        } catch (e) { console.error(e); }
    }

    // --- History Modal (Simplified for now) ---
    function openHistoryModal() {
        document.getElementById('history-modal').classList.remove('hidden');
        // If we want full history, we might need to fetch it or use what we have? 
        // For now, let's just show a placeholder or re-render the current view larger.
        // Implementing full history grid lazily would be best.
        // Leaving blank for brevity as requested focus is on Graphs.
    }
    function closeHistoryModal() {
        document.getElementById('history-modal').classList.add('hidden');
    }

</script>
{% endblock %}